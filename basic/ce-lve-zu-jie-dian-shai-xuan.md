# 策略组节点筛选

UI界面过滤器使用正则筛选，配置内相应参数为：`policy-regex-filter`

&#x20;**常用正则**

<pre><code><strong>(A.*B|B.*A)
</strong>匹配包含A和B的字符串。可以是A在B之前或B在A之前，两者之间可以有任意字符。

^(?!.*A)
匹配不包含A的字符串。使用负向前瞻来断言字符串中不会出现A。

^(?!.*B).*A
匹配包含A但不包含B的字符串。首先使用负向前瞻断言字符串中不会出现B，然后匹配A。

(A).*(B)|(B).*(A)
匹配节点名既有A又有B的字符串。使用分组和|操作符匹配两种模式：(A).*(B)匹配A后跟B之间的任意字符，(B).*(A)匹配B后跟A之间的任意字符。

(A)|(B)
匹配节点名中包含A或者B的字符串。使用|操作符匹配A或B。

^((?!A).)*$
匹配不包含A的字符串。使用负向前瞻来断言字符串中不会出现A，然后匹配任意字符。

^(?!.*A).*B
匹配不包含A但包含B的字符串。首先使用负向前瞻来断言字符串中不会出现A，然后匹配任意字符直到遇到B。

^(?=.*A)(?=.*B).*$
匹配同时包含A和B的字符串。使用正向前瞻来断言字符串中同时存在A和B。

^(?!.*A.*B).*$
匹配不同时包含A和B的字符串。使用负向前瞻来断言字符串中不会同时出现A和B。

(A.*B.*C)|(C.*B.*A)|(B.*A.*C)|(C.*A.*B)|(B.*C.*A)|(A.*C.*B)
匹配同时包含A、B和C的字符串，且它们的顺序可以是任意的。列举了所有可能的顺序组合。

(\b[A-Za-z]+\b).*\1
匹配包含重复单词的字符串。使用捕获组和反向引用来匹配首次出现的单词，并确保后续出现的单词与之相同。

(?!.*\d)[A-Za-z]+
匹配不包含数字的字母字符串。使用负向前瞻来断言字符串中不会出现数字，并匹配一个或多个字母。
</code></pre>

注意分隔符 | 必须使用英文格式

建议使用Chat GPT写正则

在线正则训练：[https://regex101.com/r/1paXsy/1](https://regex101.com/r/1paXsy/1)



返回导航页面：[mu-lu-dao-hang.md](../mu-lu-dao-hang.md "mention")
